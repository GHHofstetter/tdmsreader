#!/usr/bin/env Rscript

library(futile.logger)
library(magrittr)

flog.threshold(DEBUG)

#definitions
kTocMetaData <- bitwShiftL(1, 1)
kTocRawData <- bitwShiftL(1, 3)
kTocDAQmxRawData <- bitwShiftL(1, 7)
kTocInterleavedData <- bitwShiftL(1, 5)
kTocNewObjList <- bitwShiftL(1, 2)

tdsDataType <- new.env()

tdsDataType[["0"]] <- "tdsTypeVoid"
tdsDataType[["1"]] <- "tdsTypeI8"
tdsDataType[["2"]] <- "tdsTypeI16"
tdsDataType[["3"]] <- "tdsTypeI32"
tdsDataType[["4"]] <- "tdsTypeI64"
tdsDataType[["5"]] <- "tdsTypeU8"
tdsDataType[["6"]] <- "tdsTypeU16"
tdsDataType[["7"]] <- "tdsTypeU32"
tdsDataType[["8"]] <- "tdsTypeU64"
tdsDataType[["9"]] <- "tdsTypeSingleFloat"
tdsDataType[["10"]] <- "tdsTypeDoubleFloat"
tdsDataType[["11"]] <- "tdsTypeExtendedFloat"
tdsDataType[["25"]] <- "tdsTypeSingleFloatWithUnit"
tdsDataType[["12"]] <- "tdsTypeDoubleFloatWithUnit"
tdsDataType[["13"]] <- "tdsTypeExtendedFloatWithUnit"
tdsDataType[["32"]] <- "tdsTypeString"
tdsDataType[["33"]] <- "tdsTypeBoolean"
tdsDataType[["68"]] <- "tdsTypeTimeStamp"
tdsDataType[["79"]] <- "tdsTypeFixedPoint"
tdsDataType[["524300"]] <- "tdsTypeComplexSingleFloat"
tdsDataType[["1048589"]] <- "tdsTypeComplexDoubleFloat"
tdsDataType[["-1"]] <- "tdsTypeDAQmxRawData"

tdsDataLen <- new.env()

tdsDataLen[["tdsTypeVoid"]] = 4
tdsDataLen[["tdsTypeI8"]] = 1
tdsDataLen[["tdsTypeI16"]] = 2
tdsDataLen[["tdsTypeI32"]] = 4
tdsDataLen[["tdsTypeI64"]] = 8
tdsDataLen[["tdsTypeU8"]] = 4
tdsDataLen[["tdsTypeU16"]] = 8
tdsDataLen[["tdsTypeU32"]] = 16
tdsDataLen[["tdsTypeU64"]] = 32
tdsDataLen[["tdsTypeSingleFloat"]] = 4
tdsDataLen[["tdsTypeDoubleFloat"]] = 8
tdsDataLen[["tdsTypeTimeStamp"]] = 16


tdmsObjects <- new.env()


options <- commandArgs(trailingOnly = TRUE)
if (length(options) < 1) {
    stop("Usage: tdmsreader <file>")
}


# open file
f <- file(options[1], "rb")


#lead in
version <- readChar(f, 4)
if (version != "TDSm") {
    flog.error("File format error")
}


kTocType <- readBin(f, integer(), size = 4)
version <- readBin(f, integer(), size = 4)
nextSegmentOffset <- readBin(f, integer(), size = 8)
rawDataOffset <- readBin(f, integer(), size = 8)

flog.debug("raw %d", rawDataOffset)
flog.debug("kTocType 0x%02x", kTocType)

nObjects <- readBin(f, integer(), size = 4)

flog.debug("nObjects %d", nObjects)


readString <- function(f) {
    s <- readBin(f, integer(), size = 4)
    readChar(f, s)
}


readType <- function(f, type) {
    s <- 0
    if(type == 12 || type == 10) {
        s <- readBin(f, numeric(), size = 8)
    }
    else if(type == 25 || type == 9) {
        s <- readBin(f, numeric(), size = 4)
    }
    else if(type == 4 || type == 8) {
        s <- readBin(f, integer(), size = 8)
    }
    else if(type == 3 || type == 7) {
        s <- readBin(f, integer(), size = 4)
    }
    else if(type == 2 || type == 6) {
        s <- readBin(f, integer(), size = 2)
    }
    else if(type == 1 || type == 5) {
        s <- readBin(f, integer(), size = 1)
    }
    else if(type == 68) {
        s_frac <- readBin(f, integer(), size = 8)
        s_t <- readBin(f, integer(), size = 8)
        s <- s_t + s_frac / 2^64
    }
    else {
        s <- 0
    }
    s
}

for(j in 1:nObjects) {
    objectPath <- readString(f)

    # todo add !kTocNewObjList
    self <- new.env()
    tdmsObjects[[objectPath]] <- self
    
    flog.debug("object: %s", objectPath)


    rawDataIndex <- readBin(f, integer(), size = 4)
    if (rawDataIndex == -1) {
        self[["hasData"]] <- FALSE
    } else if (rawDataIndex == 0x00000000) {
        flog.debug("Object has same data structure as in previous segment")
        self[["hasData"]] <- TRUE
    } else {
        self[["hasData"]] <- TRUE

        s <- readBin(f, integer(), size = 4)
        self[["dataType"]] <- tdsDataType[[as.character(s)]]
        self[["dimension"]] <- readBin(f, integer(), size = 4)
        #stopifnot(self[["dimension"]] == 1)


        self[["nVals"]] <- readBin(f, integer(), size = 8)
        
        if (self[["dataType"]] == "tdsTypeString") {
            self[["dataSize"]] <- readBin(f, integer(), size = 8)
        } else {
            self[["dataSize"]] <- self[["nVals"]] * tdsDataLen[[self[["dataType"]]]] * self[["dimension"]]
        }
    }
    
    nPropGroup = readBin(f, integer(), size = 4)
    if (nPropGroup == 0) {
        flog.debug("No properties for %s", objectPath)
    } else {
        for(i in 1:nPropGroup) {
            propName = readString(f)
            propType = readBin(f, integer(), size = 4)
            self[["propType"]] <- propType
            
            if (propType == 32) {
                s = readString(f)
                flog.debug("%s = %s", propName, s)
                self[["propVal"]] = s
            } else {
                s = readType(f, propType)
                flog.debug("%s = %f %d [ns]", propName, s, propType)
                self[["propVal"]] = s
            }
        }
    }
}

close(f)
