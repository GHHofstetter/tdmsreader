#!/usr/bin/env Rscript

library(futile.logger)

flog.threshold(DEBUG)

tdsDataType <- list(list(length = 0, id = 0, name = "tdsTypeVoid"), list(length = 1, 
    id = 1, name = "tdsTypeI8"), list(length = 2, id = 2, name = "tdsTypeI16"), 
    list(length = 4, id = 3, name = "tdsTypeI32"), list(length = 8, id = 4, 
        name = "tdsTypeI64"), list(length = 1, id = 5, name = "tdsTypeU8"), 
    list(length = 2, id = 6, name = "tdsTypeU16"), list(length = 4, id = 7, 
        name = "tdsTypeU32"), list(length = 8, id = 8, name = "tdsTypeU64"), 
    list(length = 4, id = 9, name = "tdsTypeSingleFloat"), list(length = 8, 
        id = 10, name = "tdsTypeDoubleFloat"), list(length = 16, id = 68, 
        name = "tdsTypeTimeStamp"))


tdms_objects <- list()


options <- commandArgs(trailingOnly = TRUE)
if (length(options) < 1) {
    stop("Usage: tdmsreader <file>")
}


# open file
f <- file(options[1], "rb")


# lead in
version <- readChar(f, 4)
if (version != "TDSm") {
    flog.error("File format error")
}

kTocType <- readBin(f, integer(), size = 4)
kTocMetaData <- kTocType & bitwShiftL(1, 1)
kTocRawData <- kTocType & bitwShiftL(1, 3)
kTocDAQmxRawData <- kTocType & bitwShiftL(1, 7)
kTocInterleavedData <- kTocType & bitwShiftL(1, 5)
kTocBigEndian <- kTocType & bitwShiftL(1, 6)
kTocNewObjList <- kTocType & bitwShiftL(1, 2)



version <- readBin(f, integer(), size = 4)
next_segment_offset <- readBin(f, integer(), size = 8)
raw_data_offset <- readBin(f, integer(), size = 8)


# Calculate data and next segment position
lead_size = 7 * 4
data_position = lead_size + raw_data_offset

number_objects <- readBin(f, integer(), size = 4)


getType <- function(id) {
    for (elt in tdsDataType) {
        if (elt$id == id) {
            return(elt)
        }
    }
    return(NULL)
}




readString <- function(f) {
    s <- readBin(f, integer(), size = 4)
    readChar(f, s)
}


readType <- function(f, type) {
    s <- 0
    if (type == 12 || type == 10) {
        s <- readBin(f, numeric(), size = 8)
    } else if (type == 25 || type == 9) {
        s <- readBin(f, numeric(), size = 4)
    } else if (type == 4 || type == 8) {
        s <- readBin(f, integer(), size = 8)
    } else if (type == 3 || type == 7) {
        s <- readBin(f, integer(), size = 4)
    } else if (type == 2 || type == 6) {
        s <- readBin(f, integer(), size = 2)
    } else if (type == 1 || type == 5) {
        s <- readBin(f, integer(), size = 1)
    } else if (type == 68) {
        s_frac <- readBin(f, integer(), size = 8)
        s_t <- readBin(f, integer(), size = 8)
        s <- s_t + s_frac/2^64
    }
    return(s)
}

calculate_chunks <- function(self) {
    ds = lapply(tdms_objects, function(elt) {
        return(elt$data_size)
    })
    data_size = sum(unlist(ds))
    
    total_data_size = next_segment_offset - raw_data_offset
    
    if (data_size < 0 || total_data_size < 0) {
        stop("Negative data size")
    } else if (data_size == 0) {
        if (total_data_size != data_size) {
            stop("Zero channel data size but non-zero data length based on segment offset.")
        }
        self$num_chunks = 0
        return(0)
    }
    chunk_remainder = total_data_size%%data_size
    if (chunk_remainder == 0) {
        self$num_chunks = total_data_size%/%data_size
        # for (obj in tdms_objects) { if (obj$has_data) { obj$number_values =
        # obj/obj$number_values + (obj$number_values * self$num_chunks) } }
        return(self$num_chunks)
    } else {
        flog.warning("Data size %d is not a multiple of the chunk size %d. Will attempt to read last chunk", 
            total_data_size, data_size)
        self$num_chunks = 1 + total_data_size
        self$final_chunk_proportion = chunk_remainder/data_size
        
        for (obj in self$ordered_objects) {
            if (obj$has_data) {
                obj$tdms_object$number_values = obj$tdms_object$number_values + 
                  (obj$number_values * (self$num_chunks - 1) + obj$number_values * 
                    self$final_chunk_proportion)
            }
        }
        return(self$num_chunks)
    }
}

for (j in 1:number_objects) {
    object_path <- readString(f)
    
    # todo add !kTocNewObjList
    self <- list()
    
    flog.debug("object: %s", object_path)
    
    
    raw_data_index <- readBin(f, integer(), size = 4)
    if (raw_data_index == -1) {
        self$has_data <- FALSE
    } else if (raw_data_index == 0) {
        flog.debug("Object has same data structure as in previous segment")
        self$has_data <- TRUE
    } else {
        self$has_data <- TRUE
        
        s <- readBin(f, integer(), size = 4)
        self$data_type <- getType(s)
        self$dimension <- readBin(f, integer(), size = 4)
        self$number_values <- readBin(f, integer(), size = 8)
        flog.debug("numval %d", self$number_values)
        
        if (self$data_type$name == "tdsTypeString") {
            self$data_size <- readBin(f, integer(), size = 8)
        } else {
            self$data_size <- self$number_values * self$data_type$len * 
                self$dimension
        }
    }
    
    num_properties = readBin(f, integer(), size = 4)
    if (num_properties == 0) {
        flog.debug("No properties for %s", object_path)
    } else {
        for (i in 1:num_properties) {
            prop_name = readString(f)
            prop_type = readBin(f, integer(), size = 4)
            self$prop_type <- prop_type
            
            if (prop_type == 32) {
                s = readString(f)
                flog.debug("%s = %s", prop_name, s)
                self$prop_val = s
            } else {
                s = readType(f, prop_type)
                flog.debug("%s = %f %d [ns]", prop_name, s, prop_type)
                self$prop_val = s
            }
        }
    }
    
    
    tdms_objects[[object_path]] <- self
}
num_chunks = calculate_chunks(self)

flog.debug("nso %d %d", next_segment_offset, data_position)


read_raw_data <- function(self, f) {
    total_data_size = next_segment_offset - raw_data_offset
    seek(f, data_position)
    
    num_elts = total_data_size/8
    flog.debug("tds %f", total_data_size)
    flog.debug("nv %d", self$number_values)
    
    r = numeric(num_elts)
    
    for (j in 1:num_chunks) {
        for (i in 1:self$number_values) {
            r[i] = readBin(f, numeric(), size = 8)
        }
    }
    return(r)
}



i = 0
for (self in tdms_objects) {
    if (self$has_data) {
        r = read_raw_data(self, f)
        png(paste0(i, ".png"))
        plot(r, type = "l")
        dev.off()
    }
    i = i + 1
}


close(f)
