#!/usr/bin/env Rscript

library(futile.logger)
library(magrittr)

flog.threshold(DEBUG)

#definitions
kTocMetaData <- bitwShiftL(1, 1)
kTocRawData <- bitwShiftL(1, 3)
kTocDAQmxRawData <- bitwShiftL(1, 7)
kTocInterleavedData <- bitwShiftL(1, 5)
kTocNewObjList <- bitwShiftL(1, 2)

tdsDataType <- list(
list(length = 0, id = 0, name = "tdsTypeVoid"),
list(length = 1, id = 1, name = "tdsTypeI8"),
list(length = 2, id = 2, name = "tdsTypeI16"),
list(length = 4, id = 3, name = "tdsTypeI32"),
list(length = 8, id = 4, name = "tdsTypeI64"),
list(length = 1, id = 5, name = "tdsTypeU8"),
list(length = 2, id = 6, name = "tdsTypeU16"),
list(length = 4, id = 7, name = "tdsTypeU32"),
list(length = 8, id = 8, name = "tdsTypeU64"),
list(length = 4, id = 9, name ="tdsTypeSingleFloat"),
list(length = 8, id = 10, name = "tdsTypeDoubleFloat"),
list(length = 16, id = 68, name = "tdsTypeTimeStamp")
)


tdmsObjects <- new.env()


options <- commandArgs(trailingOnly = TRUE)
if (length(options) < 1) {
    stop("Usage: tdmsreader <file>")
}


# open file
f <- file(options[1], "rb")


#lead in
version <- readChar(f, 4)
if (version != "TDSm") {
    flog.error("File format error")
}


kTocType <- readBin(f, integer(), size = 4)
version <- readBin(f, integer(), size = 4)
next_segment_offset <- readBin(f, integer(), size = 8)
raw_data_offset <- readBin(f, integer(), size = 8)


# Calculate data and next segment position
leadSize = 7 * 4
data_position = leadSize + raw_data_offset

flog.debug("raw %d", raw_data_offset)
flog.debug("kTocType 0x%02x", kTocType)

nObjects <- readBin(f, integer(), size = 4)

flog.debug("nObjects %d", nObjects)


getType <- function(id) {
	for(elt in tdsDataType) {
		if(elt$id == id) {
			return (elt)
		}
	}
	return (NULL)
}




readString <- function(f) {
    s <- readBin(f, integer(), size = 4)
    readChar(f, s)
}


readType <- function(f, type) {
    s <- 0
    if(type == 12 || type == 10) {
        s <- readBin(f, numeric(), size = 8)
    }
    else if(type == 25 || type == 9) {
        s <- readBin(f, numeric(), size = 4)
    }
    else if(type == 4 || type == 8) {
        s <- readBin(f, integer(), size = 8)
    }
    else if(type == 3 || type == 7) {
        s <- readBin(f, integer(), size = 4)
    }
    else if(type == 2 || type == 6) {
        s <- readBin(f, integer(), size = 2)
    }
    else if(type == 1 || type == 5) {
        s <- readBin(f, integer(), size = 1)
    }
    else if(type == 68) {
        s_frac <- readBin(f, integer(), size = 8)
        s_t <- readBin(f, integer(), size = 8)
        s <- s_t + s_frac / 2^64
    }
    else {
        s <- 0
    }
    s
}

calculateChunks <- function(self) {
    data_size = sum(sapply(self$ordered_objects, function(elt) {
		elt$data_size
	}))

    total_data_size = next_segment_offset - raw_data_offset

    if (data_size < 0 || total_data_size < 0) {
        stop("Negative data size")
    } else if (data_size == 0) {
        if (total_data_size != data_size) {
            stop("Zero channel data size but non-zero data length based on segment offset.")
        }
		self$num_chunks = 0
		return (0)
    }
    chunk_remainder = mod(total_data_size, data_size)
    if (chunk_remainder == 0) {
        self$num_chunks = total_data_size
        for (obj in self$ordered_objects) {
            if (obj$has_data) {
                obj$tdms_object$number_values = obj/tdms_object$number_values + (obj$number_values * self$num_chunks)
            }
        }
    } else {
        flog.warning("Data size %d is not a multiple of the chunk size %d. Will attempt to read last chunk", total_data_size, data_size)
        self$num_chunks = 1 + total_data_size
        self$final_chunk_proportion = chunk_remainder / data_size

        for (obj in self$ordered_objects) {
            if (obj$has_data) {
                obj$tdms_object$number_values = obj$tdms_object$number_values + (obj$number_values * (self$num_chunks - 1) + obj$number_values * self$final_chunk_proportion)
            }
        }
    }
}

for(j in 1:nObjects) {
    object_path <- readString(f)

    # todo add !kTocNewObjList
    self <- new.env()
    tdmsObjects[[object_path]] <- self
    
    flog.debug("object: %s", object_path)


    raw_data_index <- readBin(f, integer(), size = 4)
    if (raw_data_index == -1) {
        self$has_data <- FALSE
    } else if (raw_data_index == 0x00000000) {
        flog.debug("Object has same data structure as in previous segment")
        self$has_data <- TRUE
    } else {
        self$has_data <- TRUE

        s <- readBin(f, integer(), size = 4)
        self$data_type <- getType(s)
        self$dimension <- readBin(f, integer(), size = 4)
        #stopifnot(self$dimension == 1)


        self$nVals <- readBin(f, integer(), size = 8)
        
        if (self$data_type$name == "tdsTypeString") {
            self$data_size <- readBin(f, integer(), size = 8)
        } else {
            self$data_size <- self$nVals * self$data_type$len * self$dimension
        }
    }
    
    num_properties = readBin(f, integer(), size = 4)
    if (num_properties == 0) {
        flog.debug("No properties for %s", object_path)
    } else {
        for(i in 1:num_properties) {
            prop_name = readString(f)
            prop_type = readBin(f, integer(), size = 4)
            self$prop_type <- prop_type
            
            if (prop_type == 32) {
                s = readString(f)
                flog.debug("%s = %s", prop_name, s)
                self$prop_val = s
            } else {
                s = readType(f, prop_type)
                flog.debug("%s = %f %d [ns]", prop_name, s, prop_type)
                self$prop_val = s
            }
        }
    }


}
flog.debug("nso %d %d",next_segment_offset, data_position)
total_data_size = next_segment_offset - raw_data_offset
seek(f, data_position)

num_elts = total_data_size / 4
flog.debug("tds %f", total_data_size)
r = numeric(num_elts)
for(i in 1:num_elts) {
	r[i] = readBin(f, numeric(), size = 4)
}

png('r.png')
plot(r,ylim=c(-1000,1000))
dev.off()
close(f)
