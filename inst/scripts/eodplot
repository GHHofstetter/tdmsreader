#!/usr/bin/env Rscript

library(tdmsreader)
suppressPackageStartupMessages(library('optparse'))
parser <- OptionParser()
parser <- add_option(parser, c('-f', '--file'), dest='tdms', help='TDMS file input')
parser <- add_option(parser, c('-p', '--peak'), dest='peak', help='Peak file input')
parser <- add_option(parser, c('-v', '--verbose'), dest='verbose', help='Print verbose output')
parser <- add_option(parser, c('-c', '--channel'), dest='channel', help='Channel name')
parser <- add_option(parser, c('-w', '--window'), dest='window', type = 'double', help='Window size around peak value')
parser <- add_option(parser, c('-o', '--out'), dest='out', help='Output png')

options = commandArgs(trailingOnly = TRUE)
opts = parse_args(parser, args = options)

if (is.null(opts$tdms) || is.null(opts$peak)) {
    stop('Usage: eodplot -f <tdms file> -p <peak file>')
}

if (!file.exists(opts$tdms)) {
    stop('File not found')
}
m = file(opts$tdms, 'rb')
main = TdmsFile$new(m)
peaks = read.table(opts$peak)



c = ifelse(is.null(opts$channel), "/'Untitled'/'Dev1/ai0'", opts$channel)
r = main$objects[[c]]
if(is.null(r)) {
    stop('Channel not found')
}

max = r$number_values * r$properties[['wf_increment']]
e = ifelse(is.null(opts$end), max, opts$end)
s = ifelse(is.null(opts$start), 0, opts$start)
ws = ifelse(is.null(opts$window), 0.1, opts$window)



plotdata = data.frame(col = numeric(0), time = numeric(0), dat = numeric(0))
print(peaks)
for(i in 1:nrow(peaks)) {
    print(sprintf('start2 %f %f', peaks[i,1], ws))
    s = peaks[i, 1] - ws / 2
    e = peaks[i, 1] + ws / 2
    print(sprintf('start %f %f', s, e))
    main$read_data(m, s, e)
    t = r$time_track(start = s, end = e)
    t = t - ret[i, 1]
    dat = r$data
    if(ret[i, 2] == '-') {
        dat = -dat
    }

    # rounding important here to avoid different values being collapsed. significant digits may change on sampling rate of tdms
    plotdata = rbind(plotdata, data.frame(col = ret[i, ]$start, time = round(t, digits=5), data = dat))
}

for(i in unique(plotdata$col)) {
    dat = plotdata[plotdata$col == i, ]$data
    if(input$preBaselineSubtract) {
        dat = dat - mean(dat[1:25])
    }
    if(input$normalize) {
        dat = (dat - min(dat)) / (max(dat) - min(dat))
    }
    if(input$postBaselineSubtract) {
        dat = dat - mean(dat[1:25])
    }
    plotdata[plotdata$col == i, ]$data = dat
}

png(paste0(opts$file, '.average.png', width=800, height=600)
myplot = ggplot(data=plotdata, aes(x=time, y=data)) + stat_summary(aes(y = data), fun.y=mean, geom='line')
myplot
dev.off()
png(paste0(opts$file, '.all.png', width=800, height=600)
myplot = ggplot(data=plotdata, aes(x=time, y=data, group=col)) + geom_line()
myplot
dev.off()

#if(input$analyzeWaveform) {
#    r = myreact()
#    myplot = myplot + geom_point(data = r, aes(x=time, y=val, color=landmark), size = 4) + scale_colour_brewer(palette = "Set1")
#
#    output$landmarks = DT::renderDataTable(r)
#    output$stats = renderText(sprintf('P1-P2: %f\nT2-T1: %f',
#        r[r$landmark=='p1',]$val - r[r$landmark=='p2',]$val,
#        r[r$landmark=='t2',]$time - r[r$landmark=='t1',]$time)
#    )
#
#
#    if(input$drawTwoPercent) {
#        ret = acast(plotdata, time ~ col, value.var = 'data', fun.aggregate = mean)
#        avg = apply(ret, 1, mean)
#        data = data.frame(time=as.numeric(names(avg)), val=as.numeric(avg))
#
#        baseline = mean(data$val[1:50])
#        myplot = myplot + geom_hline(yintercept = baseline, color = 'red')
#        myplot = myplot + geom_hline(yintercept = baseline + 0.02 * (r[r$landmark=='p1',]$val - r[r$landmark=='p2',]$val), color = 'yellow')
#        myplot = myplot + geom_hline(yintercept = baseline - 0.02 * (r[r$landmark=='p1',]$val - r[r$landmark=='p2',]$val), color = 'green')
#    }
#}
#
#
#    plotdata = dataMatrix()
#        ret = acast(plotdata, time ~ col, value.var = 'data', fun.aggregate = mean)
#        avg = apply(ret, 1, mean)
#        data = data.frame(time = as.numeric(names(avg)), val = as.numeric(avg))
#        p1pos = which.max(data$val)
#        p1 = data[p1pos, ]
#        p2pos = which.min(data$val)
#        p2 = data[p2pos, ]
#        leftside = data[1:p1pos, ]
#        middle = data[p1pos:p2pos, ]
#        rightside = data[p2pos:nrow(data), ]
#
#        baseline = mean(data$val[1:25])
#        p0 = NULL
#        t1 = NULL
#        t2 = NULL
#        slope1 = NULL
#        slope2 = NULL
#        s1 = NULL
#        s2 = NULL
#        zc1 = NULL
#        zc2 = NULL
#        for(i in nrow(leftside):1) {
#            if(leftside[i, 'val'] < baseline) {
#                zc1 = leftside[i,]
#                tzc1 = zc1$time
#                p0calculator = leftside[leftside$time >= tzc1-0.0005 & leftside$time <= tzc1,]
#                p0 = p0calculator[which.min(p0calculator$val), ]
#                break
#            }
#        }
#        for(i in nrow(leftside):1) {
#            if(leftside[i, 'val'] < baseline + 0.02 * (p1$val - p2$val)) {
#                t1 = leftside[i,]
#                slope1 = leftside[i:nrow(leftside), ]
#                break
#            }
#        }
#        for(i in 1:nrow(rightside)) {
#            if(rightside[i, 'val'] > baseline - 0.02 * (p1$val - p2$val)) {
#                t2 = rightside[i,]
#                break
#            }
#        }
#
#        slope1_max = -100000
#        for(i in 1:(nrow(slope1)-1)) {
#            s = (slope1[i+1, 'val'] - slope1[i, 'val']) / (slope1[i+1, 'time'] - slope1[i, 'time'])
#            if(s > slope1_max) {
#                slope1_max = s
#                s1 = slope1[i,]
#            }
#        }
#        slope2_max = 100000
#        for(i in 1:(nrow(middle)-1)) {
#            s = (middle[i+1, 'val'] - middle[i, 'val']) / (middle[i+1, 'time'] - middle[i, 'time'])
#            if(s < slope2_max) {
#                slope2_max = s
#                s2 = middle[i, ]
#            }
#        }
#        for(i in 1:nrow(middle)) {
#            if(middle[i, 'val'] < baseline) {
#                zc2 = middle[i,]
#                break
#            }
#        }
#
#
#
#        ret = data.frame(landmark = 'p0', time = p0$time, val = p0$val)
#        ret = rbind(ret, data.frame(landmark = 'p1', time = p1$time, val = p1$val))
#        ret = rbind(ret, data.frame(landmark = 'p2', time = p2$time, val = p2$val))
#        ret = rbind(ret, data.frame(landmark = 't1', time = t1$time, val = t1$val))
#        ret = rbind(ret, data.frame(landmark = 't2', time = t2$time, val = t2$val))
#        ret = rbind(ret, data.frame(landmark = 's1', time = s1$time, val = s1$val))
#        ret = rbind(ret, data.frame(landmark = 's2', time = s2$time, val = s2$val))
#        ret = rbind(ret, data.frame(landmark = 'zc1', time = zc1$time, val = zc1$val))
#        ret = rbind(ret, data.frame(landmark = 'zc2', time = zc2$time, val = zc2$val))
#        ret
close(m)
